# 3.Vue全家桶使用

---

## 🔥Vuex

---

### 1.为什么需要Vuex ？

- Vue是单向数据流的，但是在日常开发中总会遇到一个问题，就是一个数据会在多个组件或者页面中使用，如果此数据被修改，那么其他使用这个数据的组件也会同时更改
- 方法一：在最顶层建立一个 状态管理，然后层层进行传递（此方法不行，层层传递很脆弱，不知道哪一层就会出现问题）
- 方法二：provide/inject 实现 解决了层层传递的问题，但是如果状态树太大，此方法还是不行

**我们的需求是 需要动态的注册和响应式数据，还需要有命名空间来管理组织我们的数据，需要插件来记录我们的数据更改，方便我们调试**

这些功能，这都是 Vuex 的功能

<img src="https://itzkp-1253302184.cos.ap-beijing.myqcloud.com/notes/2.notes/5.MVVM%E6%A1%86%E6%9E%B6%EF%BC%88Vue%EF%BC%89/Vue%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/18Vuex%E5%8E%9F%E7%90%86.png" />

**问题：Vuex是通过什么方式提供响应式数据的？（可以看看源代码，Vuex源代码有1000行左右）**

---

### 2.如何在Vue中使用Vuex

```js
// main.js
Vue.use(Vuex)

const store = new Vuex.Stare({
    state: {
        count: 1
    },
    mutations: {
        countAdd(state, n) {
            state.count += n
        }
    },
    actions: { // 经常在里面做异步的请求（例如向后端请求数据，这个放到 mutations 里面就不行了）
        asyncCountADD({state}) {
            setTimeout( () => {
                state.count += 1
            }, 1000)
        }
    },
    getters: { // 类似于计算属性，可以帮我们缓存数据
        doubleCountAdd(state) {
            return state.count *= 2
        }
    }
})

// 使用Vuex中的数据
this.$store.state

// 修改Vuex中的数据
this.$store.commit('countAdd', 2)

// 使用 actions 修改 Vuex数据
this.$store.dispatch('asyncCountADD')

// 使用 getters
this.$store.getters.doubleCountAdd

```

- **思考**：$store 是如何挂载到实例 this 上的？
- **思考**：Vue.use() 的原理是什么？


---

### 3.Vue核心概念以及底层原理


---

## 🔥Vue-Router



---




